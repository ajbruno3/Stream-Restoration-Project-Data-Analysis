---
title: "Project Data Analysis"
author: "Anthony Bruno"
date: "2023-10-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
library(ggplot2)
```

Load raw Data
```{r}
# Specify the file path to your CSV file
file_path <- "rawdata.csv"

# Read the CSV file and create a data frame
streamData <- read.csv(file_path)
```

First, lets visualize the data:
 
Lets look at some plots for total N 
Look at Total N vs. Type
```{r}
ggplot(data = streamData, aes(x= Type, y = Total.N)) +
  stat_boxplot() + 
  ggtitle("Total N for each treatment")
```
Plot of Total N vs. distance
```{r}
ggplot( data = streamData, aes( x = Distance, y = Total.N, color = Type, shape = Type)) + 
  geom_point() +
  ggtitle("Total N vs. Distance from Stream Bank") +
  theme_minimal()
```
Box plots of Total N for each type at each distance
```{r}
ggplot(streamData, aes( y = Total.N, fill = Type)) +
  geom_boxplot() +
  facet_wrap(~ Distance, nrow = 1) +
  labs( x = "Distance from stream bank") +
  theme(axis.text.x = element_blank()) +
  ggtitle("Total N concentrations at Each Distance")
 
```





Inorganic N for each Treatment
```{r}
ggplot(data = streamData, aes(x= Type, y = Inorg.N)) +
  stat_boxplot() + 
  ggtitle("Inorganic N for each treatment")
```

Plot of Inorganic N vs distance colored by treatment type
```{r}
ggplot( data = streamData, aes( x = Distance, y = Inorg.N, color = Type)) + 
  geom_point() +
  ggtitle("Inorganic N vs. Distance from Stream Bank")
```

```{r}
ggplot(streamData, aes( y = Inorg.N, fill = Type)) +
  geom_boxplot() +
  facet_wrap(~ Distance, nrow = 1) +
  labs( x = "Distance from stream bank") +
  theme(axis.text.x = element_blank()) +
  ggtitle("Inorganic N concentrations at Each Distance")
```

Compare CSS Total N with No CSS Total N 
Create function to calculate and store resampled differences
```{r}
resampled_diff <- function(thisStreamData) {
  # Resample the response variable with replace = TRUE
  thisStreamData$resampledResponse <- sample(thisStreamData$Total.N, replace = TRUE)
  
  # Create a new data frame to store the resampled results
  resampled_data <- data.frame(Type = thisStreamData$Type, resampledResponse = thisStreamData$resampledResponse)
  
  # Calculate the sum of Total N for each treatment type in the resampled data
  summed_data <- resampled_data %>%
    group_by(Type) %>%
    summarize(tot_n = sum(resampledResponse))
  
  # Calculate the difference in total N for each treatment type
  diff_data <- summed_data %>%
    mutate(tot_n_diff = diff(tot_n))
  
  return(diff_data$tot_n_diff[1])
}

# Replicate the function and store the differences
num_replications <- 1000  # Change this to the desired number of replications

resampled_differences <- replicate(num_replications, resampled_diff(streamData))

```

Create distribution of Tot N differences
```{r}
hist(resampled_differences)
```
Find Probablility of difference greater than or equal too observed_diff
```{r}
observed_diff <- 120
mean(resampled_differences > observed_diff)
```


function for resampling and fitting the dat
```{r}
resampleAndFit=function(thisStreamData){
  #within the function, streamData does not exist, but thisStreamData does
  
  #resample the response variable with replace = true
  thisStreamData$resampledResponse=sample(thisStreamData$Total.N,replace=T)
  
  #fit a lm to the resampled dataset, save it as resampleFit
  resampleFit=lm(thisStreamData$resampledResponse~thisStreamData$Distance)
  
  #points or fitted lines representing the resampled data can be added to the plot by uncommenting out these lines:
  #points(resampledResponse~thisStreamData$Distance,pch=2)
  #abline(resampleFit)
  
  #return the slope coefficient
 return(resampleFit$coefficients[[2]])
}

```

#run the command 'resampleAndFit(streamData)' 1000 times, and save the output as resampledSlopes
```{r}
resampledSlopes=replicate(100,resampleAndFit(streamData))
```

#is 1000 enough?  test by running a few times and seeing if the p value changes

#take a look at the distribution of the resampled slopes:

```{r}
hist(resampledSlopes)
```

#remember that in all the resampled data, there is no meaningful relationship between the x and y variables.
#therefore, the mean of the resampledSlopes should be close to 0.  If it's not, something is wrong

```{r}
mean(resampledSlopes)
```


#A p value as the probability that a pattern (e.g., slope) equivalent to 
# or more extreme than the observed pattern would occur if in fact there was no meaningful relationship.


# In this example, we are predicting a positive correlation (a positive slope).
# Therefore, we want to ask what proportion of the population of slopes fitted to the
# randomly resampled dataset are GREATER THAN the observed slope in the actual data
# the '>' operator asks weather resampledSlopes is greater than the actual fitted coefficient
# this returns a set of TRUE or FALSE values:
# TRUE where the resampled slope is greater than the slope of the actual data,
# and FALSE where the resampled slope is less than the slope of the actual data,
# R can also think of TRUE and FALSE as 1 and 0, thus the mean of the T/F set is the proportion of TRUEs

#therefore, this value is the p value:
```{r}
mean(resampledSlopes> 0.2)
```
